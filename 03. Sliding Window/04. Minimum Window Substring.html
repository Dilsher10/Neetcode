<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimum Window Substring</title>
</head>

<body>
    <script>
        function minWindow(s, t) {
            // If t is an empty string, no window is needed
            if (t === '') return '';

            // Create frequency map for characters in t
            let countT = {};    // stores how many times each character appears in t
            let window = {};    // stores how many times each character appears in the current window of s

            for (let c of t) {
                countT[c] = (countT[c] || 0) + 1;
            }

            // Initialize the number of characters that match between window and countT
            let have = 0;
            let need = Object.keys(countT).length;  // total unique characters needed from t

            // Result variables: store best window's left/right pointers and length
            let res = [-1, -1];
            let resLen = Infinity;

            let l = 0; // Left pointer of the sliding window

            // Right pointer of the sliding window moves through s
            for (let r = 0; r < s.length; r++) {
                let c = s[r];
                window[c] = (window[c] || 0) + 1;

                // There are two conditions are check:
                // First is countT[c] this checks that current character of window is presents in countT are not. means Only count characters that present in coutnT.
                // Second is window[c] === countT[c] this checks that current character of window is equal of countT character.

                if (countT[c] && window[c] === countT[c]) {
                    have++;
                }

                // When all required characters are matched
                while (have === need) {
                    // Update result if this window is smaller than previously found windows
                    if (r - l + 1 < resLen) {
                        resLen = r - l + 1;
                        res = [l, r];
                    }

                    // Start shrinking the window from the left
                    window[s[l]]--;

                    // If a required character falls below its required frequency, reduce 'have'
                    if (countT[s[l]] && window[s[l]] < countT[s[l]]) {
                        have--;
                    }

                    l++; // Move left pointer forward
                }
            }

            // If no valid window was found, return empty string; otherwise return the substring
            return resLen === Infinity ? '' : s.slice(res[0], res[1] + 1);
        }

        s = "OUZODYXAZV", t = "XYZ"
        console.log(minWindow(s, t));
    </script>
</body>

</html>