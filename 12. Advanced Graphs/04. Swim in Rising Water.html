<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swim in Rising Water</title>
</head>

<body>
    <script>
        function swimInWater(grid) {
            const N = grid.length; // Get the size of the grid (N x N)
            const visit = new Set(); // Keep track of visited cells to avoid revisiting
            const minPQ = new MinPriorityQueue((entry) => entry[0]);
            // Priority queue ordered by the "time" or elevation needed to reach a cell.
            // Each entry is [time, row, col]

            const directions = [
                [0, 1],  // right
                [0, -1], // left
                [1, 0],  // down
                [-1, 0], // up
            ];

            // Start from the top-left cell (0, 0), with initial time as grid[0][0]
            minPQ.push([grid[0][0], 0, 0]);
            visit.add('0,0'); // Mark the starting cell as visited

            // Continue until all reachable nodes have been processed
            while (!minPQ.isEmpty()) {
                const [t, r, c] = minPQ.pop(); // Pop the cell with the minimum elevation/time

                // If we've reached the bottom-right cell, return the time
                if (r === N - 1 && c === N - 1) {
                    return t;
                }

                // Explore all 4 adjacent directions
                for (const [dr, dc] of directions) {
                    const neiR = r + dr;
                    const neiC = c + dc;

                    // Skip if out of bounds or already visited
                    if (
                        neiR < 0 ||
                        neiC < 0 ||
                        neiR >= N ||
                        neiC >= N ||
                        visit.has(`${neiR},${neiC}`)
                    ) {
                        continue;
                    }

                    visit.add(`${neiR},${neiC}`); // Mark neighbor as visited

                    // Push neighbor to priority queue with updated time (max of current time and neighbor's elevation)
                    minPQ.push([Math.max(t, grid[neiR][neiC]), neiR, neiC]);
                }
            }
        }
    </script>
</body>

</html>