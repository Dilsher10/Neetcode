<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Add and Search Word Data Structure</title>
</head>

<body>
    <script>
        // Trie node class representing each character node
        class TrieNode {
            constructor() {
                this.children = new Map();  // Map to store child nodes (character -> TrieNode)
                this.word = false;          // Marks whether this node is the end of a valid word
            }
        }

        // WordDictionary using Trie structure
        class WordDictionary {
            constructor() {
                this.root = new TrieNode(); // Root node of the Trie
            }



            addWord(word) {
                let cur = this.root;

                for (const c of word) {
                    // If character doesn't exist as a child, create a new TrieNode
                    if (!cur.children.has(c)) {
                        cur.children.set(c, new TrieNode());
                    }

                    // Move to the next node
                    cur = cur.children.get(c);
                }

                // Mark the end node as a complete word
                cur.word = true;
            }




            search(word) {
                return this.dfs(word, 0, this.root);  // Start DFS from index 0 and root node
            }




            // Recursive depth-first search to handle '.' wildcards
            dfs(word, index, node) {

                let cur = node;

                for (let i = index; i < word.length; i++) {
                    const c = word[i];

                    // If character is '.', check all possible children
                    if (c === '.') {
                        for (const child of cur.children.values()) {
                            // Recurse for each child; if any path returns true, word exists
                            if (this.dfs(word, i + 1, child)) {
                                return true;
                            }
                        }
                        // No matching paths found for wildcard
                        return false;
                    }

                    // If character doesn't exist in children, word doesn't exist
                    if (!cur.children.has(c)) {
                        return false;
                    }

                    // Move to the next child node
                    cur = cur.children.get(c);
                }

                // Return true only if we end on a node that marks the end of a word
                return cur.word;
            }
        }


        const dict = new WordDictionary();
        dict.addWord("bat");
        dict.addWord("bad");
        dict.addWord("pad");

        console.log(dict.search("bat"));   // true
        console.log(dict.search("b.t"));   // true ('.' matches 'a')
        console.log(dict.search("ba."));   // true
        console.log(dict.search("..."));   // true
        console.log(dict.search("b.."));   // true
        console.log(dict.search("pa."));   // true
        console.log(dict.search("cat"));   // false
    </script>
</body>

</html>
